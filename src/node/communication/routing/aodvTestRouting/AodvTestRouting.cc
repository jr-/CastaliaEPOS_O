/*
 * @Author: Mathieu MICHEL (http://w3.umons.ac.be/staff/Michel.Mathieu/)
 *
 * Copyright (C) 2013  Mathieu MICHEL
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


#include "AodvTestRouting.h"
#include <csimulation.h>
#include <CastaliaModule.h>
#include <ResourceManager.h>
using namespace std;
Define_Module(AodvTestRouting);

void AodvTestRouting::startup()
{
	activeRouteTimeout = (double)par("activeRouteTimeout") / 1000.0;
	allowedHelloLoss = par("allowedHelloLoss");
	helloInterval = (double)par("helloInterval") / 1000.0;
	localAddTTL = par("localAddTTL");
	netDiameter = par("netDiameter");
	frameSize = par("frameSize");
	//int activeRouteTimeoutTemp = par("activeRouteTimeout");
	//activeRouteTimeout = (activeRouteTimeoutTemp + (frameSize * netDiameter)/2)/1000.0;
	nodeTraversalTime = (double)par("nodeTraversalTime") / 1000.0;
	netTraversalTime = 2*nodeTraversalTime*netDiameter;
	pathDiscoveryTime = 2*netTraversalTime;
	rerrRatelimit = par("rerrRatelimit");
	rreqRetries = par("rreqRetries");
	rreqRatelimit = par("rreqRatelimit");
	timeoutBuffer = par("timeoutBuffer");
	ttlStart = par("ttlStart");
	ttlIncrement = par("ttlIncrement");
	ttlThreshould = par("ttlThreshould");
	shortestDelay = par("shortestDelay");
	atmode = par("atmode");

	rreqExpTime = netTraversalTime;
	rreqExpTimeB = pathDiscoveryTime;


	//test to choose the adaptation of aodv timers (depending of smac parameters)
	if(atmode !=0)
	{
		int activeRouteTimeoutTemp = par("activeRouteTimeout");
		activeRouteTimeout = activeRouteTimeoutTemp + (2 * frameSize * netDiameter)/1000.0;
		if(atmode == 2)
		{
			rreqExpTime = (2 * nodeTraversalTime * netDiameter) + (2 * frameSize * netDiameter)/1000.0;
			rreqExpTimeB = pathDiscoveryTime + (2 * frameSize * netDiameter)/1000.0;
		}
	}

	currSN = 1; //the current sequence number of this node (start from 1, 0 represents invalid value)
	rreqID = 0; //start from 1, but 0 because incremented before sending
	rtable = new AodvRoutingTable();//the routing table
	rreqTable = new AodvRREQTable();//the rreq which have been generated by this node

    declareOutput("Pkt sent");
    declareOutput("Pkt received");
    declareOutput("Timers expired");

    respTimeAverage = 0; //the average time between the generation of RREQ and the reception of RREP
    respTimeMax = numeric_limits<double>::min( ); //the minimum time between the generation of RREQ and the reception of RREP
    respTimeMin = numeric_limits<double>::max( ); //the maximum time between the generation of RREQ and the reception of RREP
    respTimeTotal = 0;
    rrepRxCount=0;



    latencyMax = hasPar("latencyHistogramMax") ? par("latencyHistogramMax") : 0;
    latencyMin = hasPar("latencyHistogramMin") ? par("latencyHistogramMin") : 0;
    latencyBuckets = hasPar("latencyHistogramBuckets") ? par("latencyHistogramBuckets") : 0;
    if (latencyMax > 0 && latencyBuckets > 0)
        declareHistogram("RREQ response time, in s", latencyMin, latencyMax, latencyBuckets);

}

void AodvTestRouting::finish()
{
    VirtualRouting::finish();
    PacketRREQ* rreqpkt;
    PacketRERR* rerrpkt;
    // clear the buffer
    while (!rreqBuffer.empty()) {
        rreqpkt = rreqBuffer.front();
        rreqBuffer.pop();
        cancelAndDelete(rreqpkt);
    }
    while (!rerrBuffer.empty()) {
        rerrpkt = rerrBuffer.front();
        rerrBuffer.pop();
        cancelAndDelete(rerrpkt);
    }

    delete rtable;
    delete rreqTable;
}

void AodvTestRouting::timerFiredCallback(int index)
{
    switch(index)
    {
        case AODV_RREQ_BROADCAST_DROP_TIMER:
        {
            trace() << "AODV : T : AODV_RREQ_BROADCAST_DROP_TIMER expired";
            rreqBroadTable.pop();
            collectOutput("Timers expired","rreq broadcasted");
            while(!rreqBroadTable.empty()!=0 && rreqBroadTable.top().lifetime - simTime().dbl()<=0)
            {
                rreqBroadTable.pop();
                collectOutput("Timers expired","rreq broadcasted");
            }
            if(!rreqBroadTable.empty())
                    setTimer(AODV_RREQ_BROADCAST_DROP_TIMER, rreqBroadTable.top().lifetime - simTime().dbl());

        }
            break;

        case AODV_RREQ_EXPIRATION_TIMER:
        {
            if(rreqTable->getTableSize()!=0)
            {
                //double nextExpiredRREQTime = rreqTable->getNextExpiredRREQ()->lifetime;
                string nextExpiredRREQ = rreqTable->getNextExpiredRREQ()->dest;
                int nextExpiredRREQID = rreqTable->getNextExpiredRREQ()->rreqID;
                rreqTable->removeRREQ(nextExpiredRREQ);
                collectOutput("Timers expired","rreq");
                trace() << "AODV : T : RREQ (generated expired) with id : "<<nextExpiredRREQID;
                if(rreqTable->getTableSize()!=0)
                    setTimer(AODV_RREQ_EXPIRATION_TIMER, rreqTable->getNextExpiredRREQ()->lifetime - simTime().dbl());
                if(rreqRetryCount[nextExpiredRREQ] < rreqRetries)//send another rreq if rreqRetries number not reached
                {
                    rreqID++;
                    trace() << "AODV : RREQ : rreq resent for destination : "<<nextExpiredRREQ;
                    sendPktRREQ(0, rreqID, SELF_NETWORK_ADDRESS, nextExpiredRREQ,currSN, rtable->getDstSN(nextExpiredRREQ));
                }
                else
                {
                    trace() << "AODV : RREQ : rreq "<< nextExpiredRREQID<< " canceled for destination : "<<nextExpiredRREQ;
                    rreqRetryCount[nextExpiredRREQ] = 0;
                    processBufferedDATA(nextExpiredRREQ.c_str(),true);
                    //TODO: notify the application layer that the link is not available
                }
            }
        }
            break;

        case AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER:
        {
            trace() << "AODV : T : AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER expired";
            const RouteTimer* r = rtable->getNextExpiredRoute();
            if(r && !r->canceled)
            {
                //routeUpdateCount[r->destination]--;
                //if(routeUpdateCount[r->destination]==0)
                rtable->searchByDest(r->destination)->flag=INVALID;
                trace() << "AODV : R : expired route to " << string(r->destination);
                //rtable->removeRoute(r->dstIP);
                collectOutput("Timers expired","route");
            }
            rtable->clearTimerExpired();

            while(rtable->getTimersSize()!=0 && rtable->getNextExpiredRoute()->lifetime - simTime().dbl()<=0)
            {
                  string s = rtable->getNextExpiredRoute()->destination;
                  if(!rtable->getNextExpiredRoute()->canceled)
                  {
                        //routeUpdateCount[s]--;
                        //if (routeUpdateCount[s]==0 && rtable->getFlag(s)==VALID)
                        rtable->searchByDest(s)->flag=INVALID;

                  }
                  rtable->clearTimerExpired();
                  trace() << "AODV : R : expired route to " << s;
                  collectOutput("Timers expired","route");
            }
            if(rtable->getTimersSize()!=0)
            {
              setTimer(AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER, rtable->getNextExpiredRoute()->lifetime - simTime().dbl());
            }
        }
            break;

        case AODV_RREQ_RATE_LIMIT_TIMER:
        {
            trace() << "AODV : T : AODV_RREQ_RATE_LIMIT_TIMER expired";
            if(!rreqBuffer.empty())
            {
                processBufferedRREQ();
            }
    	   // setTimer(AODV_RREQ_RATE_LIMIT_TIMER, (double)1/rreqRatelimit);

        }
            break;

        case AODV_HELLO_MESSAGE_REFRESH_TIMER:
        {
            trace() << "AODV : T : AODV_HELLO_MESSAGE_REFRESH_TIMER expired";
            sendPktHELLO();
        }
            break;

        case AODV_HELLO_MESSAGE_EXPIRE_TIMER:
        {
            trace() << "AODV : T : AODV_HELLO_MESSAGE_EXPIRE_TIMER expired";
            string neib = helloTimer.top().destination;

            //this counter is used because an old hello message timer is not remove when we received a new one.
            //So it could be a problem when an old hello message timer expires but that a new one is already received
            hmUpdateCount[neib]--;
            if (hmUpdateCount[neib]==0)
            {
                list<string>* affectedDest = new list<string>();
                list<string>* affectedPrecursor = new list<string>();
                rtable->setLinkFailure(neib.c_str(), affectedDest, affectedPrecursor);
                resetLifetimeRoute(neib);
                sendPktRERR(affectedDest, affectedPrecursor);
                delete affectedDest;
                delete affectedPrecursor;
            }
            helloTimer.pop();
            while(!helloTimer.empty() && helloTimer.top().lifetime - simTime().dbl()<=0)
            {
                string dest3 = helloTimer.top().destination;
                hmUpdateCount[dest3]--;
                if (hmUpdateCount[dest3]==0)
                {
                    list<string>* affectedDest = new list<string>();
                    list<string>* affectedPrecursor = new list<string>();
                    rtable->setLinkFailure(dest3.c_str(), affectedDest, affectedPrecursor);
                    resetLifetimeRoute(dest3);
                    sendPktRERR(affectedDest, affectedPrecursor);
                    delete affectedDest;
                    delete affectedPrecursor;
                }
                helloTimer.pop();
            }
            if(!helloTimer.empty())
                setTimer(AODV_HELLO_MESSAGE_EXPIRE_TIMER, helloTimer.top().lifetime - simTime().dbl());
        }
            break;

        case AODV_RERR_RATE_LIMIT_TIMER:
        {
            trace() << "AODV : T : AODV_RERR_RATE_LIMIT_TIMER expired";
            if(!rerrBuffer.empty())
            {
                collectOutput("Pkt sent","RERR pkt");
                toMacLayer(rerrBuffer.front(), resolveNetworkAddress(rerrBuffer.front()->getDestination()));
                rerrBuffer.pop();
                setTimer(AODV_RERR_RATE_LIMIT_TIMER, (double)1/rerrRatelimit);
            }
        }
            break;
        case AODV_RREP_ACK_WAIT_TIMER:
        {
           trace() << "AODV : T : AODV_RREP_ACK_WAIT_TIMER expired";
            if(!rrepAcked[rrepAck.top().destination])
                setBlacklistTimer(rrepAck.top().destination.c_str());
            rrepAck.pop();
            if(!rrepAck.empty())
            {
                setTimer(AODV_RREP_ACK_WAIT_TIMER, rrepAck.top().lifetime - simTime().dbl());
            }
        }
            break;

        case AODV_RREQ_BLACKLIST_REMOVE_TIMER:
            {
                trace() << "AODV : T : AODV_RREQ_BLACKLIST_REMOVE_TIMERR expired";
                string node = string(rreqBlacklist.top().destination);
                rreqBlacklist.pop();
                if(!rreqBlacklist.empty())
                {
                	if(rreqBlacklist.top().lifetime<simTime().dbl())
                	{
                		trace()<<"debug - destination"<<node;
                		setTimer(AODV_RREQ_BLACKLIST_REMOVE_TIMER, 1);
                	}
                	else
                		setTimer(AODV_RREQ_BLACKLIST_REMOVE_TIMER, rreqBlacklist.top().lifetime - simTime().dbl());
                }
            }
            break;

        default:
            return;

    }
    return;
}

void AodvTestRouting::fromMacLayer(cPacket * pkt, int srcMacAddress, double rssi, double lqi)
{
	AODVPacketTypes packetType;
	//get the packet type (as ddefined in packet.msg files)
	PacketRREQ *rreq = dynamic_cast <PacketRREQ*>(pkt);
	PacketRREP *rrep = dynamic_cast <PacketRREP*>(pkt);
	PacketRERR *rerr = dynamic_cast <PacketRERR*>(pkt);
	PacketDATA *data = dynamic_cast <PacketDATA*>(pkt);
	PacketHELLO *hello = dynamic_cast <PacketHELLO*>(pkt);
	PacketRREPack *rrepA = dynamic_cast <PacketRREPack*>(pkt);

	if (data)
		packetType = AODV_DATA;
	else if (hello)
		packetType = AODV_HELLO;
	else if(rreq)
		packetType = AODV_RREQ;
	else if(rrep)
		packetType = AODV_RREP;
	else if(rrepA)
		packetType = AODV_RREP_ACK;
	else if(rerr)
		packetType = AODV_RERR;
	else
		packetType = AODV_UNKNOWN;


	switch(packetType)
	{
			case AODV_DATA:
			    //trace() << "AODV : A1 : DATA received - from: " << string(data->getSource())
			    //                            << " destination: " << string(data->getDestinationAodv());
				receivePktDATA(data);
				break;

			case AODV_HELLO:
                //trace() << "AODV : A1 : HELLO received - from: " << string(hello->getSource());
			    //collectOutput("Pkt received","HELLO pkt");
				receivePktHELLO(hello);
				break;

			case AODV_RREQ:
			    /*trace() << "AODV : A1 : RREQ received - origin: " << string(rreq->getSrcIP())
			                                            << " id: " << rreq->getRreqID()
			                                            << " destination: " << string(rreq->getDstIP())
			                                            << " from: " << string(rreq->getSource());*/
			    collectOutput("Pkt received","RREQ pkt");
				receivePktRREQ(rreq, srcMacAddress, rssi, lqi);
				break;

			case AODV_RREP:
                /*trace() << "AODV : A1 : RREP received - origin (AODV dst): " << string(rrep->getDstIP())
                                                        << " destination (AODv src): " << string(rrep->getOriginIP())
                                                        << " from: " << string(rrep->getSource());*/
				receivePktRREP(rrep, srcMacAddress, rssi, lqi);
				break;

			case AODV_RREP_ACK:
			    trace() << "AODV : RREPack : received - from: " << string(rrepA->getSource());
			    if(string(rrepA->getDestination()).compare(SELF_NETWORK_ADDRESS)==0)
			    {
			        collectOutput("Pkt received","RREPack pkt");
			        rrepAcked[string(rrepA->getSource())] = true;
			    }
				break;

			case AODV_RERR:
			    //trace() << "AODV : A1 : RERR received - from: " << string(rerr->getSource());
				receivePktRERR(rerr, srcMacAddress, rssi, lqi);
				break;

			default:
				return;
	}
	return;

}

//application layer can only send data packets
void AodvTestRouting::fromApplicationLayer(cPacket * pkt, const char *destination)
{
	PacketDATA *data = new PacketDATA("AODV routing data packet", NETWORK_LAYER_PACKET);
	data->setSource(SELF_NETWORK_ADDRESS);
	data->setDestinationAodv(destination);
	data->setDestination(destination);
	encapsulatePacket(data, pkt);
	trace() << "AODV : A : DATA received from application layer - destination " << string(destination);
	if(string(destination).compare(BROADCAST_NETWORK_ADDRESS)==0)
	{
   	    //do not route broadcast package
	    toMacLayer(data, BROADCAST_MAC_ADDRESS);
	    return;
	}


	//a valid route exist
	if(rtable->isRouteValid(string(destination)))
	{
			updateLifetimeRoute(string(destination), activeRouteTimeout);
			trace() << "AODV : B1 : DATA sent (route valid) - destination " << string(destination)
			                                                <<" via " <<rtable->getNextHop(destination);

			data->setDestination((rtable->getNextHop(destination)).c_str());
			collectOutput("Pkt sent","DATA pkt (S)");
			toMacLayer(data, resolveNetworkAddress((rtable->getNextHop(destination)).c_str()));
			return;
	}

	//a rreq is already processed
	else if(!(AodvTestRouting::checkRREQProcessed(string(destination))))
	{
			currSN++;
			rreqID++;
			sendPktRREQ(0, rreqID, string(SELF_NETWORK_ADDRESS), string(destination), currSN, rtable->getDstSN(destination));
			//buffer the packet

	}

	//no valid route and no discovery process
	else
		trace() << "AODV : B1 : RREQ already processed - for destination " << string(destination);
    trace() << "AODV : B2 : DATA buffered - destination " << string(destination);
    bufferPacket(data);



}


void AodvTestRouting::receivePktDATA(PacketDATA *pkt)
{
	string finalDst = string(pkt->getDestinationAodv());

	//packet to be broadcasted
	if(finalDst.compare(BROADCAST_NETWORK_ADDRESS)==0)
	{
		toApplicationLayer(pkt->decapsulate());
		return;
	}

	//packet not destined to this node (this node isn't the next hop to the final dst)
	if((string(pkt->getDestination())).compare(SELF_NETWORK_ADDRESS)!=0)
	{
	    /*trace() << "AODV : A2 : DATA received has been discarded - from: " << string(pkt->getSource())
	                                    << " destination: " << string(pkt->getDestinationAodv())

	                                    << " receiver: " << string(pkt->getDestination());*/
		trace()<<"NOT FOR ME R "<< pkt->getDestination() <<" "<< SELF_NETWORK_ADDRESS;
		return;
	}

	trace() << "AODV : DATA : RX : from: " << string(pkt->getSource())
				                                << " destination: " << string(pkt->getDestinationAodv());

	PacketDATA* ndPacket = pkt->dup();

	//the final destination is this node
	if(finalDst.compare(SELF_NETWORK_ADDRESS)==0)
	{
	    collectOutput("Pkt received","DATA pkt (D)");
	    trace() << "AODV : DATA : sent to application - origin: " << string(pkt->getSource());

		toApplicationLayer(pkt->decapsulate());
		cancelAndDelete(ndPacket);
		return;
	}

	collectOutput("Pkt received","DATA pkt (F)");
	//the packet is forwarded to the next hop (case where a route is known)
	if(rtable->isRouteValid(finalDst))
	{

			updateLifetimeRoute(finalDst, activeRouteTimeout);
			ndPacket->setDestination((rtable->getNextHop(finalDst)).c_str());
            trace() << "AODV : DATA : forwarded to destination " << string(finalDst)
                                                            <<" via " <<rtable->getNextHop(finalDst);
			collectOutput("Pkt sent","DATA pkt (F)");
			toMacLayer(ndPacket, resolveNetworkAddress((rtable->getNextHop(finalDst)).c_str()));
			//cancelAndDelete(pkt);
			return;
	}

	//a route exist but is not valid anymore
	else if(rtable->searchByDest(finalDst) && rtable->searchByDest(finalDst)->flag==INVALID)
	{
		trace() << "AODV : DATA : TX : rejected (no route anymore) - destination: " << finalDst;
	     list<string>* affectedDest = new list<string>();
	     list<string>* affectedPrecursor = new list<string>();
	     affectedDest->push_front(finalDst);
	     affectedPrecursor->push_front(ndPacket->getSource());
	     sendPktRERR(affectedDest, affectedPrecursor);
	     delete affectedDest;
	     delete affectedPrecursor;
	}
	trace() << "AODV : DATA : buffered for destination " << finalDst;
    bufferPacket(ndPacket);
    //cancelAndDelete(pkt);
}

void AodvTestRouting::receivePktRREQ(PacketRREQ* pkt,int srcMacAddress, double rssi, double lqi)
{
	if(isBlacklisted(pkt->getSource()))
	{
	    trace() << "AODV : RREQ : discarded (blacklist) - origin: " << string(pkt->getSrcIP())
	                                                       << " id: " << pkt->getRreqID()
	                                                       << " from" << string(pkt->getSource());
	    return;
	}



	trace() << "AODV : RREQ : RX : origin: " << string(pkt->getSrcIP())
				                                            << " id: " << pkt->getRreqID()
				                                            << " destination: " << string(pkt->getDstIP())
				                                            << " from: " << string(pkt->getSource());
	//updates a route to the previous hop without a valid seq number
	updateRoute(string(pkt->getSource()), 0, false, VALID, 1, string(pkt->getSource()),NULL,0);

	//check if this node is the origin of the request
	if(string(pkt->getSrcIP()).compare(SELF_NETWORK_ADDRESS)==0)
		return;

	//check if this node has already processed or buffered this rreq, if yes drop packet
	if(checkRREQBroadcasted(pkt->getSrcIP(), pkt->getRreqID()) || checkRREQBuffered(pkt->getSrcIP(), pkt->getRreqID()))
	{
	    trace() << "AODV : RREQ : discarded (already broadcasted) - origin: " << string(pkt->getSrcIP())
                                                        << " id: " << pkt->getRreqID();
	    return;
	}

	//update route for the originator
	updateRoute(string(pkt->getSrcIP()), pkt->getSrcSN(), true, VALID, pkt->getHopCount() + 1, string(pkt->getSource()),NULL,0);

    if(string(pkt->getDstIP()).compare(SELF_NETWORK_ADDRESS)==0) //current node is the destination (RFC3561 chapter 6.6.1)
    {
        if(pkt->getDstSN()==currSN)
            currSN++;
        trace() << "AODV : RREQ : RX : final dst - origin: " << string(pkt->getSrcIP())
                                                                << " id: " << pkt->getRreqID();
        updateRreqBroadcastedList(pkt->getDstIP(), pkt->getSrcIP(), pkt->getRreqID());
        int timeout = 2*activeRouteTimeout;//MY_ROUTE_TIMOUT = 2 * ACTIVE_ROUTE_TIMEOUT

        collectOutput("Pkt sent","RREP pkt (S)");
	    trace() << "AODV : RREQ : reach destination - origin: " << string(pkt->getSrcIP())
                                                        << " id: " << pkt->getRreqID();
	    trace() << "AODV : RREP : succes : sent (is the destination)";


        sendPktRREP(0, string(pkt->getSrcIP()), string(SELF_NETWORK_ADDRESS), currSN, timeout, false, pkt->getRreqID());
        return;
    }
    if(rtable->isRouteValid(pkt->getDstIP()))//current node has an active route to the destination (RFC3561 chapter 6.6.2)
    {

        Route *r = rtable->searchByDest(pkt->getDstIP());
        updateRreqBroadcastedList(pkt->getDstIP(), pkt->getSrcIP(), pkt->getRreqID());

        if(pkt->getDstSN() < r->dstSN && r->state)
        {
            trace() << "AODV : RREQ : succes : find a valid route - origin: " << string(pkt->getSrcIP())
                                                                                    << " id: " << pkt->getRreqID();
    	    trace() << "AODV : RREP : sent (knows the destination)";
            string srcIP = string(pkt->getSrcIP());
            string dstIP = string(pkt->getDstIP());
            int hopcount = rtable->getHopCount(dstIP);
            unsigned long dstSN = rtable->getDstSN(dstIP);
            double time = getLifetimeRoute(dstIP)-simTime().dbl();
            collectOutput("Pkt sent","RREP pkt (R)");
            sendPktRREP(hopcount,srcIP,dstIP,dstSN,time,false,pkt->getRreqID());
            return;
        }
    }
    //forward the rreq

	int hopcount = pkt->getHopCount() + 1;
	int id = pkt->getRreqID();
	string srcIP = pkt->getSrcIP();
	string dstIP = pkt->getDstIP();
	unsigned long srcSN = pkt->getSrcSN();
	unsigned long dstSN;
	if(pkt->getDstSN() >= rtable->getDstSN(dstIP))
		dstSN = pkt->getDstSN();
	else
		dstSN = rtable->getDstSN(dstIP);

	sendPktRREQ(hopcount, id, srcIP, dstIP, srcSN, dstSN);

}

void AodvTestRouting::receivePktRREP(PacketRREP* pkt,int srcMacAddress, double rssi, double lqi)
{
    if(string(pkt->getDestination()).compare(SELF_NETWORK_ADDRESS)!=0)
    {
        /*trace() << "AODV : A2 : RREP received has been discarded - from: " << string(pkt->getSource())
                                        << " destination: " << string(pkt->getOriginIP())
                                        << " receiver: " << string(pkt->getDestination());*/
        return;
    }
    trace() << "AODV : RREP : RX : origin (AODV dst): " << string(pkt->getDstIP())
                                                            << " destination (AODv src): " << string(pkt->getOriginIP())
                                                            << " from: " << string(pkt->getSource())
    														<< " rreqID: " << pkt->getRreqID();

    sendPktRREPack(pkt->getSource());

    //updates a route to the previous hop without a valid seq number
    updateRoute(string(pkt->getSource()), 0, false, VALID, 1, string(pkt->getSource()),NULL,0);
    //update route for the destination
    updateRoute(string(pkt->getDstIP()), pkt->getDstSN(),true, VALID, pkt->getHopCount() + 1, string(pkt->getSource()),NULL,pkt->getLifetime());

    if(getTimer(AODV_HELLO_MESSAGE_REFRESH_TIMER).dbl()<=0)
        sendPktHELLO();
    if (!(string(pkt->getOriginIP()).compare(SELF_NETWORK_ADDRESS)==0))
    {
        //forward the rrep
        collectOutput("Pkt received","RREP pkt (F)");
        collectOutput("Pkt sent","RREP pkt (F)");
        sendPktRREP(pkt->getHopCount() + 1, string(pkt->getOriginIP()), string(pkt->getDstIP()), pkt->getDstSN(),pkt->getLifetime(),true,pkt->getRreqID());
    }
    else //the RREQ originator receives a RREP and has updated his route --> he can processed the buffered packets
    {
    	if(!rreqAnswered[pkt->getRreqID()] && shortestDelay)
    	{
    		trace()<<"shortestDelay enabled";
    		return;
    	}
    	rreqAnswered[pkt->getRreqID()]=true;
    	if(rreqTable->searchByDest(pkt->getDstIP()))
    	{
			if(rreqTable->searchByID(pkt->getRreqID()))
			{
				//calculation linked to response time
				double spendTime =simTime().dbl() - rreqSendTimes[pkt->getRreqID()];

				if(spendTime < respTimeMin)
					respTimeMin = spendTime;
				if(spendTime > respTimeMax)
					respTimeMax = spendTime;
				respTimeTotal = respTimeTotal + spendTime;
				rrepRxCount++;
				respTimeAverage = respTimeTotal/rrepRxCount;
				trace()<<"AODV : D1 : RREP received - from: "<< " RREP sender: " << string(pkt->getDstIP())<< " - time spent :"<<spendTime;
				trace()<<"AODV : D2 : number of nodes : "<< pkt->getHopCount()+1;
				//trace()<<"AODV : D2 : RREP rx time : current ="<<spendTime;
				//trace()<<"AODV : D2 : RREP rx time : maximum ="<<respTimeMax;
				//trace()<<"AODV : D2 : RREP rx time : mimimum ="<<respTimeMin;
				//trace()<<"AODV : D2 : RREP rx time : average("<<rrepRxCount<<") ="<<respTimeAverage;

				if (latencyMax > 0 && latencyBuckets > 0)
					 collectHistogram("RREQ response time, in s", spendTime);

				rreqTable->removeRREQ(pkt->getRreqID());

			}
			else
				trace() << "AODV : RREP : received but no existing id "<< pkt->getRreqID();
			collectOutput("Pkt received","RREP pkt (D)");
			rreqRetryCount[string(pkt->getDstIP())] = 0;
			processBufferedDATA(pkt->getDstIP(), false);
    	}
    	else
    		trace() << "AODV : RREP : discarded (no RREQ "<< pkt->getDstIP()<<" )";
     }

}

void AodvTestRouting::receivePktRERR(PacketRERR* pkt,int srcMacAddress, double rssi, double lqi)
{
    if(string(pkt->getDestination()).compare(SELF_NETWORK_ADDRESS)!=0)
    {
        /*trace() << "AODV : REER : RERR received has been discarded - from: " << string(pkt->getSource())
                                        << " receiver: " << string(pkt->getDestination());*/
        return;//rerr not adressed to the node
    }

    trace() << "AODV : RERR : RX : from: " << string(pkt->getSource());

    collectOutput("Pkt received","RERR pkt");
    unsigned int affDestCount = (unsigned int)pkt->getDestCount();
    if (affDestCount!=pkt->getUnreachableDstIPArraySize() || affDestCount!=pkt->getUnreachableDstSNArraySize())
        return;//broken rerr packet

    list<string>* affDest = new list<string>();
    list<string>* affPre = new list<string>();

    for (unsigned int i = 0; i < affDestCount; i++)
    {
        affDest->push_front(string(pkt->getUnreachableDstIP(i)));
        rtable->setDstSN(pkt->getUnreachableDstIP(i),pkt->getUnreachableDstSN(i));
    }

    rtable->forwardLinkFailure(pkt->getSource(),affDest,affPre);
    sendPktRERR(affDest,affPre);
    delete affDest;
    delete affPre;
}

void AodvTestRouting::receivePktHELLO(PacketHELLO* pkt)
{
    trace() << "AODV : A2 : HELLO received - origin: " << string(pkt->getSource());
    aodvTimer ht;
    hmUpdateCount[string(pkt->getSource())]++;
    ht.destination = string(pkt->getSource());
    ht.lifetime = allowedHelloLoss * helloInterval + simTime().dbl();
    helloTimer.push(ht);
    if(getTimer(AODV_HELLO_MESSAGE_EXPIRE_TIMER).dbl()<=0)
    {
        setTimer(AODV_HELLO_MESSAGE_EXPIRE_TIMER, helloTimer.top().lifetime - simTime().dbl());
    }
}

void AodvTestRouting::sendPktRREQ(int hopCount, int id, string srcIP, string dstIP, unsigned long srcSN, unsigned long dstSN)
{
	PacketRREQ* rreq = new PacketRREQ("AODV routing RREQ packet", NETWORK_LAYER_PACKET);
	rreq->setFlagD(false);
	rreq->setFlagG(false);
	rreq->setFlagJ(false);
	rreq->setFlagR(false);
	rreq->setFlagU(false);
	rreq->setHopCount(hopCount);
	rreq->setRreqID(id);
	//RREQ dst
	rreq->setDstIP(dstIP.c_str());
	rreq->setDstSN(dstSN);
	//RREQ src
	rreq->setSrcIP(srcIP.c_str());
	rreq->setSrcSN(srcSN);
	rreq->setSource(SELF_NETWORK_ADDRESS);
	rreq->setDestination(dstIP.c_str());
	if (getTimer(AODV_RREQ_RATE_LIMIT_TIMER).dbl() <= 0)
	{
		//rreqRetryCount[dstIP]++;
		updateRreqBroadcastedList(dstIP, srcIP, id);

		if(srcIP.compare(SELF_NETWORK_ADDRESS)==0)
		{
	            updateRreqTable(dstIP,id);
	            collectOutput("Pkt sent","RREQ pkt (S)");
	            //two next lines used because map need a string
	            trace() << "AODV : RREQ : generated for destination " << string(dstIP);
		}
		rreqRetryCount[dstIP]++;//a RREQ has been sent
		// A node SHOULD NOT originate more than RREQ_RATELIMIT RREQ messages per second
		setTimer(AODV_RREQ_RATE_LIMIT_TIMER, (double)1/rreqRatelimit);
		collectOutput("Pkt sent","RREQ pkt (F)");
        trace() << "AODV : RREQ : forwarded to destination " << string(dstIP);
		toMacLayer(rreq, BROADCAST_MAC_ADDRESS);
	}
	else
	{
	    trace() << "AODV : RREQ : buffered for destination " << dstIP;
		rreqBuffer.push(rreq);
	}

}

void AodvTestRouting::sendPktRREP(int hopCount, string rreqSrc, string rreqDst, unsigned long dstSN, double lifetime, bool forwarding, int idFromRREQ)
{
	//srcIP is the originator of the rreq --> the destination for the RREP
	//dstIP is the final destination of the rreq --> the source for the RREP
	if(!(rtable->isRouteValid(rreqSrc)))//le noeud n'a pas de route vers la destination (srcIP)
	{
		trace()<<"AODV : RREP : TX : rejected (no route)";
		return;
	}
	PacketRREP *rrep = new PacketRREP("AODV routing RREP packet", NETWORK_LAYER_PACKET);
	rrep->setFlagA(true);
	rrep->setFlagR(false);
	rrep->setPrefixSz(0);
	rrep->setHopCount(hopCount);
	rrep->setOriginIP(rreqSrc.c_str());
	rrep->setDstIP(rreqDst.c_str());
	rrep->setDstSN(dstSN);
	rrep->setSource(SELF_NETWORK_ADDRESS);
	rrep->setDestination((rtable->getNextHop(rreqSrc)).c_str());
	rrep->setLifetime(lifetime);
	rrep->setRreqID(idFromRREQ);

	if(string(rreqDst).compare(SELF_NETWORK_ADDRESS)!=0)
	{
		rtable->addPrecursor(rreqDst, string(rtable->getNextHop(rreqSrc)));
	}
	if(forwarding)
		updateLifetimeRoute(rreqSrc, activeRouteTimeout);
	toMacLayer(rrep, resolveNetworkAddress((rtable->getNextHop(rreqSrc)).c_str()));

	setRrepAckTimer((rtable->getNextHop(rreqSrc)).c_str());
}

void AodvTestRouting::sendPktHELLO()
{
    //A node SHOULD only use hello messages if it is part of an active route
    if(rtable->isPartRouteValid())
    {
        PacketHELLO* helloMsg = new PacketHELLO("AODV hello message packet", NETWORK_LAYER_PACKET);
        helloMsg->setSource(SELF_NETWORK_ADDRESS);
        helloMsg->setDestination(BROADCAST_NETWORK_ADDRESS);
        trace() << "AODV : B1 : HELLO msg broadcasted";
        collectOutput("Pkt sent","HELLO pkt");
        toMacLayer(helloMsg, BROADCAST_MAC_ADDRESS);
        setTimer(AODV_HELLO_MESSAGE_REFRESH_TIMER, helloInterval);
    }
}

void AodvTestRouting::sendPktRERR(list<string>* affDst, list<string>* affPre)
{
	if(affDst->empty() || affPre->empty())
	{
		return;
	}
	for (list<string>::const_iterator i=affPre->begin();i!=affPre->end();++i)
	{
		const char* dest = (*i).c_str();

		int destCount = affDst->size();
		PacketRERR *rerr = new PacketRERR("AODV routing RERR packet", NETWORK_LAYER_PACKET);
		rerr->setSource(SELF_NETWORK_ADDRESS);
		rerr->setFlagN(true);
		rerr->setDestCount(destCount);
		rerr->setUnreachableDstIPArraySize(destCount);
		rerr->setUnreachableDstSNArraySize(destCount);
		rerr->setDestination(dest);
		for(int i=0;i<destCount;i++)
		{
			rerr->setUnreachableDstIP(i,affDst->front().c_str());
			rerr->setUnreachableDstSN(i,rtable->getDstSN(affDst->front().c_str()));
			affDst->pop_front();
		}
		if(getTimer(AODV_RERR_RATE_LIMIT_TIMER).dbl() <= 0)
		{
			trace() << "AODV : RERR : TX : to  " << string(dest);
			collectOutput("Pkt sent","RERR pkt");
			toMacLayer(rerr, resolveNetworkAddress(dest));
			setTimer(AODV_RERR_RATE_LIMIT_TIMER, (double)1/rerrRatelimit);
		}
		else
		{
			trace() << "AODV : RERR : buffered for  " << string(dest);
			rerrBuffer.push(rerr);
		}
	}
}

void AodvTestRouting::sendPktRREPack(const char* neib)
{
	PacketRREPack *rrepA = new PacketRREPack("AODV routing RREP ACK packet", NETWORK_LAYER_PACKET);
	rrepA->setSource(SELF_NETWORK_ADDRESS);
	rrepA->setDestination(neib);
	collectOutput("Pkt sent","RREPack pkt");
	toMacLayer(rrepA, resolveNetworkAddress(neib));
}

void AodvTestRouting::updateLifetimeRoute(string dstIP, double time)
{
    Route* r = rtable->searchByDest(dstIP);
    if(r && rtable->getFlag(dstIP)==VALID)
    {
        routeUpdateCount[dstIP]++;
        RouteTimer newTimer;
        newTimer.destination = string(dstIP);
        newTimer.lifetime = simTime().dbl() + time;
        newTimer.canceled = false;
        trace() << "AODV : R : extended route lifetime to " << dstIP;
        rtable->setLifetime(&newTimer);
    }
}

double AodvTestRouting::getLifetimeRoute(const string dstIP)
{
	return rtable->getLifetime(dstIP);
}

void AodvTestRouting::resetLifetimeRoute(const string dstIP)
{
    rtable->resetTimer(dstIP);
    routeUpdateCount[dstIP]=0;
}

/**
 * \brief update the RreqRequest queue
 * \details a RREQ is really sent (not in the buffer)
 * \param dst the rreq final destination
 */

void AodvTestRouting::updateRreqTable(string dstIP, int id)
{
	//wait time should be (2^RETRY_COUNT)*NET_TRAVERSAL_TIME
	//NET_TRAVERSAL_TIME = 2*NODE_TRAVERSAL_TIME*NET_DIAMETER
    if(rreqTable->isRREQExpired(dstIP) || rreqRetryCount[dstIP]>rreqRetries)
        return;
	//double expTime = 2 * nodeTraversalTime * netDiameter;
	double lifetime = rreqExpTime * pow(double(2),double(rreqRetryCount[dstIP]));
	/*if(lifetime < simTime().dbl())
	{
        trace()<<"debug - dstIP : "<<dstIP<<" - id :"<<id;
	    return;
	}*/

	//if the first to expire changes
    RREQset* r = rreqTable->getNextExpiredRREQ();
    if(r && lifetime<r->lifetime)
           cancelTimer(AODV_RREQ_EXPIRATION_TIMER);

    rreqTable->insertRREQ(dstIP,simTime().dbl()+lifetime,id);
    rreqSendTimes[id]= simTime().dbl();
    r = rreqTable->getNextExpiredRREQ();
    double nextExpiredRREQTime = r->lifetime;

    if(getTimer(AODV_RREQ_EXPIRATION_TIMER).dbl()<=0)
    {
        setTimer(AODV_RREQ_EXPIRATION_TIMER, nextExpiredRREQTime - simTime().dbl());
    }
}

/**
 * \brief update the RreqBroadcast queue
 * \details a RREQ is really broadcasted (not in the buffer)
 * \param source  the rreq orginator
 * \param dst the rreq final destination
 * \param id the RREQ id
 */

void AodvTestRouting::updateRreqBroadcastedList(string dstIP, string srcIP, int id)
{
    if(checkRREQBroadcasted(srcIP,id))
        return;

	//double lifetime = simTime().dbl() + 2 * nodeTraversalTime * 1000; //PATH_DISCOVERY_TIME = 2 * NET_TRAVERSAL_TIME
    //double lifetime = simTime().dbl() + 2 * netTraversalTime; //PATH_DISCOVERY_TIME = 2 * NET_TRAVERSAL_TIME
    double lifetime = simTime().dbl() + rreqExpTimeB;

    //the first to expire change
	rreqBroadcastedTimer timer;
	timer.origin=srcIP;
	timer.id=id;
	timer.lifetime=lifetime;

    if(!rreqBroadTable.empty() && lifetime < rreqBroadTable.top().lifetime)
        cancelTimer(AODV_RREQ_BROADCAST_DROP_TIMER);

    rreqBroadTable.push(timer);

    if(getTimer(AODV_RREQ_BROADCAST_DROP_TIMER).dbl()<=0)
        setTimer(AODV_RREQ_BROADCAST_DROP_TIMER, rreqBroadTable.top().lifetime - simTime().dbl());
}

/**
 * \brief checks if a RREQ exist
 * \details looks if the RREQ is on going or still in the RREQ buffer
 * \param dst the rreq final destination
 */

bool AodvTestRouting::checkRREQProcessed(string dstIP)
{
	//on going
    if(rreqTable->searchByDest(dstIP))
        return true;

    for(const auto i : rreqBuffer)
        if(string(i->getDstIP()).compare(dstIP)==0)
            return true;
    return false;
    /*
	//buffered
	else if(!rreqBuffer.empty())
	{
		queue<PacketRREQ*> temp = rreqBuffer;//used to avoid modification of the rreqBuffer by the process who process the buffer (processBufferedRREQ)
		while(!temp.empty()) {
		    auto q1 = temp.front();
		    if(string(q1->getDstIP()).compare(dstIP)==0) {
		        return true;
		    }
		    temp.pop();
		}
	}
	return false;
	*/
}

/**
 * \brief checks if a RREQ has already been broadcasted
 * \details looks in the broadcast queue
 * \param orig the RREQ originator
 * \param idx the RREQ id
 */
bool AodvTestRouting::checkRREQBroadcasted(string orig, int idx)
{
    for(const auto & i : rreqBroadTable)
        if(i.id==idx && i.origin.compare(orig)==0)
            return true;
    return false;
    /*
    const rreqBroadcastedTimer* t;
    if(!(rreqBroadTable.empty()))
    {
        t = &(rreqBroadTable.top());
        for(unsigned int i = 0; i < rreqBroadTable.size(); i++)
        {
            if(t[i].id==idx && t[i].origin.compare(orig)==0)
            {
                return true;
            }
        }
    }
    return false;
    */
}

bool AodvTestRouting::checkRREQBuffered(string orig, int idx)
{
    for(const auto i : rreqBuffer)
        if(string(i->getSrcIP()).compare(orig)==0 && i->getRreqID()==idx)
            return true;
    return false;
    /*
	queue<PacketRREQ*> temp = rreqBuffer; //used to avoid modification of the rreqBuffer by the process who process the buffer (processBufferedRREQ)
        while(!temp.empty()) {
            auto q1 = temp.front();
            if(string(q1->getSrcIP()).compare(orig)==0 && q1->getRreqID()==idx)
                return true;
            temp.pop();
        }
	return false;
	*/
}

void AodvTestRouting::updateRoute(const string dstIP,unsigned long dstSN,bool state,RoutingFlag flag,int hopCount,const string nextHopAddr, list<string>* precursor, double aTime)
{
    //refer to RFC3561 chapter 6.2
	double oldLifetime = 0;
    if(rtable->isRouteValid(dstIP))
    	//double oldLifetime = getLifetimeRoute(dstIP);
        oldLifetime = getLifetimeRoute(dstIP);

    double addTime;
    if(aTime==0)
        addTime=activeRouteTimeout;
    else
        addTime=aTime;

    double lifetime = oldLifetime<=0 ? simTime().dbl() + addTime : oldLifetime + aTime;

    RouteTimer newTimer;
    newTimer.destination = string(dstIP);
    newTimer.lifetime = lifetime;
    newTimer.canceled = false;

    const RouteTimer* r= rtable->getNextExpiredRoute();
    if(r && lifetime < r->lifetime)
            cancelTimer(AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER);

    rtable->insertRoute(dstIP, dstSN, state, flag, hopCount, nextHopAddr, precursor, lifetime);
    rtable->setLifetime(&newTimer);

    r = rtable->getNextExpiredRoute();
    double newTime = r->lifetime;

    if(getTimer(AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER).dbl()<=0)
    {
        setTimer(AODV_ROUTING_TABLE_ENTRY_EXPIRATION_TIMER, newTime - simTime().dbl());
    }
    trace() << "AODV : R : new route created to " << dstIP;
}

void AodvTestRouting::processBufferedDATA(string dstIP, bool drop)
{
    queue< cPacket* > bufferTemp;
    PacketDATA* currPkt;
    while (!TXBuffer.empty())
    {
        currPkt = dynamic_cast <PacketDATA*>(TXBuffer.front());
        if(currPkt && string(dstIP).compare(currPkt->getDestinationAodv())==0)
        {
            if(!drop && rtable->isRouteValid(dstIP))
            {
                currPkt->setDestination(rtable->getNextHop(dstIP).c_str());
                trace() << "AODV : DATA : TX (out of buffer) - destination " << string(dstIP)
                        <<" via " <<rtable->getNextHop(dstIP);
                if(string(currPkt->getSource()).compare(SELF_NETWORK_ADDRESS)==0)
                    collectOutput("Pkt sent","DATA pkt (BS)");
                else
                    collectOutput("Pkt sent","DATA pkt (BF)");
                toMacLayer(currPkt, resolveNetworkAddress((rtable->getNextHop(dstIP)).c_str()));
            }
            else
                cancelAndDelete(currPkt);
        }
        else
        {
            bufferTemp.push(TXBuffer.front());
        }
        TXBuffer.pop();
        updateLifetimeRoute(string(dstIP), activeRouteTimeout);
    }
    while (!bufferTemp.empty()) {
        TXBuffer.push(bufferTemp.front());
        bufferTemp.pop();
    }
}

void AodvTestRouting::processBufferedRREQ()
{

	PacketRREQ* r=rreqBuffer.front();
	++rreqRetryCount[r->getDstIP()];

	if(!checkRREQBroadcasted(r->getSource(), r->getRreqID()))
		{
			updateRreqBroadcastedList(rreqBuffer.front()->getDstIP(),rreqBuffer.front()->getSrcIP(),rreqBuffer.front()->getRreqID());
			if(string(rreqBuffer.front()->getSrcIP()).compare(SELF_NETWORK_ADDRESS)==0)
			{
				updateRreqTable(r->getDstIP(), r->getRreqID());
				collectOutput("Pkt sent","RREQ pkt (BS)");
			}
			else
				collectOutput("Pkt sent","RREQ pkt (BF)");

			trace() << "AODV : B3 : RREQ sent (out of buffer) - destination " << string(r->getDstIP());

			toMacLayer(rreqBuffer.front(), BROADCAST_MAC_ADDRESS);
		    setTimer(AODV_RREQ_RATE_LIMIT_TIMER, (double)1/rreqRatelimit);
		}
	else
	    cancelAndDelete(r);
	rreqBuffer.pop();
}

void AodvTestRouting::setRrepAckTimer(const char* neib)
{
    for(const auto & i : rrepAck)
        if(i.destination.compare(neib) == 0)
            return;

    /*
    //check if is already waiting for the neighbor to ack
    const aodvTimer* t;
    if(!(rrepAck.empty()))
    {
        auto tmp = rrepAck;
        while(!tmp.empty()) {
            t = &(tmp.top());
            if(t->destination.compare(neib)==0)
                return;
            tmp.pop();
        }
    }
    */
    rrepAcked[string(neib)]=false;
    aodvTimer timer;
    timer.destination = string(neib);
    timer.lifetime = simTime().dbl() + 2 * nodeTraversalTime;
    rrepAck.push(timer);
    if(getTimer(AODV_RREP_ACK_WAIT_TIMER).dbl()<=0){
        setTimer(AODV_RREP_ACK_WAIT_TIMER, rrepAck.top().lifetime - simTime().dbl());

    }
}

bool AodvTestRouting::isBlacklisted(const char* neib)
{
    for(const auto & i : rreqBlacklist)
        if(i.destination.compare(neib) == 0)
            return true;
    return false;
    /*
    const aodvTimer* q0;
    if(!(rreqBlacklist.empty()))
    {
        auto tmp = rreqBlacklist;
        while(!tmp.empty()) {
            q0 = &(tmp.top());
            if(q0->destination.compare(neib)==0)
                return true;
            tmp.pop();
        }
    }
    return false;
    */
}

void AodvTestRouting::setBlacklistTimer(const char* neib)
{
    //check if is already in the blacklist
   if(isBlacklisted(neib))
        return;
    aodvTimer t;
    t.destination = string(neib);
    //BLACKLIST_TIMEOUT = RREQ_RETRIES * NET_TRAVERSAL_TIME
    //NET_TRAVERSAL_TIME = 2 * NODE_TREVERSAL_TIME * NET_DIAMETER
    t.lifetime = simTime().dbl() + 2 * rreqRetries * nodeTraversalTime * netDiameter;
    rreqBlacklist.push(t);
    if(getTimer(AODV_RREQ_BLACKLIST_REMOVE_TIMER).dbl()<=0){
        setTimer(AODV_RREQ_BLACKLIST_REMOVE_TIMER, rreqBlacklist.top().lifetime - simTime().dbl());

    }
}
